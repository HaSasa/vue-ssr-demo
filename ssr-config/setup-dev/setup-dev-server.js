const fs = require('fs')
const path = require('path')
const chalk = require('chalk')
const MFS = require('memory-fs')
const webpack = require('webpack')
const chokidar = require('chokidar')

const clientConfig = require('../../build/webpack.prod.conf.js')
const serverConfig = require('../../build/webpack.server.conf.js')

const webpackDevMiddleware = require('koa-webpack-dev-middleware')
const webpackHotMiddleware = require('koa-webpack-hot-middleware')
const convert = require('koa-convert')

const readline = require('readline')
const openBrowser = require('./openBrowser.js')

const readFile = (fs, file) => {
  try {
    return fs.readFileSync(path.join(clientConfig.output.path, file), 'utf-8')
  } catch (e) {}
}

const conf = {
  port: process.env.PORT || 3000, // 监听的端口
  devHost: '127.0.0.1', // 开发环境下打开的地址，监听了0.0.0.0，但是不是所有设备都支持访问这个地址，用127.0.0.1或localhost代替
  open: true // 是否打开浏览器
}

module.exports = (app, templatePath, cb) => {
  let serverTime, clientTime
  let isFrist = true
  // 清除 console
  const clearConsole = () => {
    if (process.stdout.isTTY) {
      // 用空行填充屏幕。然后移动到0(可见部分的开头)并清除它
      const blank = '\n'.repeat(process.stdout.rows)
      console.log(blank)
      readline.cursorTo(process.stdout, 0, 0)
      readline.clearScreenDown(process.stdout)
    }
  }

  let bundle
  let template
  let clientManifest

  let ready
  // const readyPromise = new Promise(r => { ready = r })

  const update = () => {
    if (bundle && clientManifest) {
      if (isFrist) {
        const url = 'http://' + conf.devHost + ':' + conf.port
        console.log(
          chalk.bgGreen.black(' DONE ') +
            ' ' +
            chalk.green(`Compiled successfully in ${serverTime + clientTime}ms`)
        )
        console.log()
        console.log(` App running at: ${chalk.cyan(url)}`)
        console.log()
        console.log()

        if (conf.open) openBrowser(url)
        isFrist = false
      }
      cb(bundle, {
        template,
        clientManifest
      })
    }
  }

  // read template from disk and watch
  template = fs.readFileSync(templatePath, 'utf-8')
  chokidar.watch(templatePath).on('change', () => {
    template = fs.readFileSync(templatePath, 'utf-8')
    console.log('index.html template updated.')
    update()
  })

  // modify client config to work with hot middleware
  clientConfig.entry.app = [
    'webpack-hot-middleware/client?path=/__webpack_hmr&timeout=2000&reload=true',
    clientConfig.entry.app
  ]
  clientConfig.output.filename = '[name].js'
  clientConfig.plugins.push(
    new webpack.HotModuleReplacementPlugin(),
    new webpack.NoEmitOnErrorsPlugin()
  )

  const clientCompiler = webpack(clientConfig)
  const devMiddleware = webpackDevMiddleware(clientCompiler, {
    // publicPath: clientConfig.output.publicPath,
    noInfo: true,
    // serverSideRender: false,
    headers: { 'Access-Control-Allow-Origin': '*' },
    stats: {
      colors: true,
      modules: false
    },
    reporter: (middlewareOptions, options) => {
      clearConsole()
      update()
    }
  })
  app.use(convert(devMiddleware))

  // hot update
  clientCompiler.plugin('done', stats => {
    stats = stats.toJson()
    stats.errors.forEach(err => console.error(err))
    stats.warnings.forEach(err => console.warn(err))
    if (stats.errors.length) return
    clientManifest = JSON.parse(
      readFile(devMiddleware.fileSystem, 'vue-ssr-client-manifest.json')
    )
    update()
    clientTime = stats.time
  })
  // hot middleware
  app.use(convert(webpackHotMiddleware(clientCompiler, { heartbeat: 5000 })))

  // ======= //
  // watch and update server renderer
  const serverCompiler = webpack(serverConfig)
  const mfs = new MFS()
  serverCompiler.outputFileSystem = mfs
  serverCompiler.watch({}, (err, stats) => {
    if (err) throw err
    stats = stats.toJson()
    if (stats.errors.length) return

    // read bundle generated by vue-ssr-webpack-plugin
    bundle = JSON.parse(readFile(mfs, 'vue-ssr-server-bundle.json'))
    update()
  })
  serverCompiler.plugin('done', stats => {
    stats = stats.toJson()
    stats.errors.forEach(err => console.error(err))
    stats.warnings.forEach(err => console.warn(err))
    if (stats.errors.length) return

    serverTime = stats.time
  })
}
